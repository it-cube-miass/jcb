## Теория
### Комбинаторика
Это область математики, которая занимается, неожиданно, подсчетом различных комбинаций чисел; перечислением, существованием, оптимизацией различных структур; вычислением размеров и количества элементов в этих структурах.
* Найдите базовые формулы комбинаторики.
* Не скрывайте друг от друга найденную информацию и ее понимание.

### Рекурсия
Шуточным объяснением рекурсии является: **"для того чтобы понять рекурсию — нужно понять рекурсию"**.

Программирование с применением рекурсии подразумевает применение рекурсивных вызовов. Это требует немного иного взгляда на решение той или иной задачи.  Рекурсивные вызовы могут оказаться проще чем, например, написание хитрых циклов и условий. Но рекурсивные вызовы хранят в себе опасность переполнения стека методов в JVM, что приводит к выбросу StackOverflowError. По легендам — эта ошибка помогла назвать соответствующий сайт с вопрос-ответами.
* Мойте руки, клавиатура не должна быть залапана.
* Найдите примеры рекурсии в java:
  * Изучите их внимательно, осознайте 
  * Поиграйтесь с ними у себя в любом тестовом классе
  * Задавайте вопросы о непонятном друг-другу, перед началом выполнения заданий
* Вопрос: какой предел стека в JVM? 

### Исключения
**Исключение** — это нештатная ситуация, ошибка во время выполнения программы. В методе, в котором происходит ошибка, создается и передается специальный объект. Метод может либо обработать исключение самостоятельно, либо пробросить его выше. В любом случае исключение ловится и обрабатывается.
* Найти информацию об исключениях в Java
* Посмотреть видео урок ["Исключения в Java"](https://youtu.be/taSTVYSHEvU)
* Посмотреть видео урок ["Иерархия исключений"](https://youtu.be/amg_fMXO2aQ)
* Выписать себе на стикер ответ на вопрос:  что общего и в  чем отличия NumberFormatException и IllegalArgumentException?

### Сортировка
**Сортировка** — это любой процесс, который включает в себя процесс упорядочивания данных в некотором значимом порядке, чтобы упростить понимание, анализ и визуализацию. 

**Сортировка массива** — это процесс распределения всех элементов массива в определенном порядке.

**Сортировка пузырьком** — это самый простой алгоритм сортировки. Он проходит по массиву несколько раз от начала и до конца, сравнивая попарно соседние элементы и на каждом этапе перемещает самое большое значение из не отсортированных в конец массива. В итоге, наименьший элемент постепенно перемещается  к началу массива — "всплывает" до нужной позиции как пузырёк в воде.
* Найти информацию об алгоритмах сортировки в Java
* Посмотреть видео ["Сортировка пузырьком"](https://youtu.be/oqpICiM165I)

### Экземпляры и классы
**Класс** — это "шаблон для объекта", который Вы создаете в Java. Класс описывает свойства и методы, которые будут доступны у объекта, построенного по описанию, заложенному в классе. 

**Экземпляр класса** (англ. instance) — это описание конкретного объекта в памяти. Экземпляры используются для представления (моделирования) конкретных сущностей реального мира. Понятие класса, как и понятие объекта, являются основой ООП.
* Найти информацию о экземплярах и классах
* Посмотреть видеоурок ["Работа с экземплярами в Java"](https://youtu.be/OMSt9o0Ke-Y?list=PLsQAG1V_t58AKvV5v4NVXxo68OyLdNX3j)

**Поле класса** — это один из членов класса, предназначенный для хранения неких данных. Поля класса объявляются перед всеми методами. Данные в полях класса могут быть представлены различными типами из мира  Java.

**Статические поля**. По аналогии с методами — это те поля класса, которые объявлены с ключевым словом ```static```. Соответственно такие поля становятся общими для всех экземпляров (объектов) текущего класса. Статическими делают поля-константы.
* Найти информацию о полях классов в Java
* **Вопрос**: что такое области видимости полей?

### Конструкторы
**Конструкторы** — это специальные методы, которые вызываются при создании объекта. Они "конструируют" новый объект определенного класса. В отличие от метода, конструктор никогда ничего не возвращает. Конструктор определяет действия, выполняемые при создании объекта класса, и является важной частью класса. 

Как правило, программисты стараются явно указать конструктор. Если явного конструктора нет, то Java автоматически создаст его для использования по умолчанию.
* Найти информацию о конструкторах в Java
* Посмотреть видео урок  ["Конструкторы в Java"](https://youtu.be/f88zS-etDWs?list=PLsQAG1V_t58AKvV5v4NVXxo68OyLdNX3j)

### Методы доступа (getters)
**Инкапсуляция** является базовой концепцией в ООП. Речь идет об обертывании данных и кода в виде единого блока. В этом случае рекомендуется объявлять переменные как private. Если переменная имеет уровень доступа private, к ней невозможно обратиться вне класса, в котором она объявлена. Но все равно необходим способ обращения к private переменным из другого класса, иначе такие изолированные переменные не будут иметь смысла. Это достигается с помощью объявления специальных public методов. 

Методы, которые возвращают значение переменных **называются getters**.
* Найти информацию о getters и setters в Java

### Неизменяемые объекты
**Неизменяемый объект** (англ. immutable objects) — это объект, который не позволяет изменять свои параметры. А если вы все-же пытаетесь что-то изменить, то получаете новый объект. Но старый останется прежним. Неизменяемые объекты полезны тем, что они изначально ориентированы на многопоточность.

Типичным представителем неизменяемых объектов являются объекты класса ```String``` — любое изменение содержимого объекта приводит к созданию нового.

Чтобы поле или переменная были неизменяемыми — его обозначают ключевым словом ```final```. Ссылка помеченная ключевым словом ```final```:
* примитив не может изменить изначально заданное ему значение
* НЕпримитив не может сменить объект, на который он ссылается с момента инициализации

Для того чтобы сделать весь объект неизменяемым — все его поля должны быть ```final```. Инициализация ```final```-полей должна происходить только в месте их объявления или в конструкторе.
* Найти информацию о неизменяемых объектах в Java
* Посмотреть видео урок ["Неизменяемые объекты"](https://youtu.be/z8bstpYRV9I)
* Найти [информацию](https://dzone.com/articles/modifying-immutable-objects-with-chained-methods) о том как обновлять неизменяемые объекты

### Строковое представление объекта
Часто необходимо узнать содержимое того или иного объекта. Для этого в классе Object языка Java определен специальный метод ```toString()```, который возвращает символьную строку, описывающую объект. При создании нового класса принято переопределение ```toString()``` таким образом, чтобы возвращающая строка содержала в себе имя класса, имена и значения всех переменных.
* Найти информацию о методе ```toString()```

### Сравнение объектов
Метод ```equals()```. Мы используем метод ```equals()``` для сравнения объектов в Java. Чтобы определить, совпадают ли два объекта, ```equals()``` сравнивает значения атрибутов объектов. Может показаться, что оператор ```==``` и метод ```equals()``` делают то же самое. Но на самом деле они работают по-разному. Оператор ```==``` лишь сравнивает указывают ли две ссылки на один и тот же объект, а ```equals()``` должен сравнивать объекты по содержимому.

Метод ```hashCode()```. Мы используем метод ```hashСode()``` для оптимизации производительности при сравнении объектов. Выполнение ```hashСode()``` возвращает уникальный идентификатор для каждого объекта в программе. Что значительно облегчает реализацию. Если хэш-код объекта не совпадает с хэш-кодом другого объекта, нет причин для выполнения метода ```equals()```. Вы просто будете знать, что два объекта не совпадают. Но если хэш-код одинаков, то нужно выполнить ```equals()```, чтобы определить, совпадают ли значения и поля объектов.

### Интерфейс Comparable
**Интерфейс Comparable** содержит один единственный метод int ```compareTo(E item)```, который сравнивает текущий объект с объектом, переданным в качестве параметра. Если этот метод возвращает отрицательное число, то текущий объект будет располагаться перед тем, который передается через параметр. Если метод вернет положительное число, то, наоборот, после второго объекта. Если метод возвращает ноль, значит, оба объекта равны.
* Найти [информацию](https://www.training.ru/#!/News/339?lang=ru) о сравнениях объектов в Java
* Найти [информацию](https://www.digizol.com/2008/07/java-sorting-comparator-vs-comparable.html) об интерфейсе ```Comparable```
* Выясните и объясните друг другу разницу в применении ```==``` и ```equals```, для сравнения объектов и примитивов

## Практическая работа
В этом задании придется опять реализовывать не только математику, но и возится со строками. Сигнатуры методов будут даны не для всех заданий текущего дня. **Разрешено**: использовать только свои реализации различных методов из этого и предыдущих дней. **Запрещено**: использовать готовые парсеры чисел и строк из библиотек java.

**Пакет**. Все классы текущего задания должны находиться в 
```java
package com.kovalevskyi.academy.codingbootcamp.week1.day0;
```

### Класс NumberUtils
Все методы этого класса статические. Некоторые из них повторяют поведение друг-друга, но должны отличаться реализацией.

Фактически в каждом методе нужно проверять аргументы на валидность, это зависит от конкретных математических ограничений для каждого метода. Если аргумент не валидный — кидать ```IllegalArgumentException```

#### Обычное вычисление факториала
Это небольшой кусочек комбинаторики. Этот метод вычисляет факториал входящего числа.  n! = 1 * 2 * 3 *... * n
```java
// сигнатура метода
public static int getFactorial(final int number) {
  // TODO
}
```

#### Рекурсивное вычисление факториала
Этот метод делает тоже самое, что и предыдущий. Но делает он это рекурсивным способом. Обязательно проверяйте друг у друга способ реализации этого метода.
```java
// сигнатура метода
public static int factorialRecursive(int number) {
 // TODO
}
```
Предусмотрите перехват нелегальных аргументов.

#### Обычное вычисление степени
Напишите метод, который принимает два числа: основу и степень. Неожиданно: основу нужно возвести в степень!
```java
// сигнатура метода
public static long power(int base, int power) {
 // TODO
}
```

#### Рекурсивное вычисление степени
Этот метод делает то же самое, что и предыдущий, но реализован с помощью рекурсии. Проверяйте способ реализации друг у друга!
```java
// сигнатура метода
public static int powerRecursive(int base, int power) {
 // TODO
}
```

#### Вычисление числа фибоначчи
[Что это?!](https://ru.wikipedia.org/wiki/%D0%A7%D0%B8%D1%81%D0%BB%D0%B0_%D0%A4%D0%B8%D0%B1%D0%BE%D0%BD%D0%B0%D1%87%D1%87%D0%B8#:~:text=0%2C%201%2C%201%2C%202,%D1%80%D0%B0%D0%B2%D0%BD%D0%BE%20%D1%81%D1%83%D0%BC%D0%BC%D0%B5%20%D0%B4%D0%B2%D1%83%D1%85%20%D0%BF%D1%80%D0%B5%D0%B4%D1%8B%D0%B4%D1%83%D1%89%D0%B8%D1%85%20%D1%87%D0%B8%D1%81%D0%B5%D0%BB.) Сам метод должен находить число фибоначчи по заданному индексу.
Метод сразу должен иметь рекурсивную реализацию. Ищем только позитивные числа фибоначчи.
```java
// сигнатура метода
public static int fibRecursive(int index) {
 // TODO
}
```

#### Вычисление ряда фибоначчи
Этот метод должен вычислить и вернуть весь ряд чисел фибоначчи. Длина ряда задается входящим в метод аргументом.
```java
// сигнатура метода
public static int[] fibSequence(int length) {
 // TODO
}
```

#### Корень квадратный
Пишем метод, который вычисляет квадратный корень для входящего числа. Находит он только целочисленные варианты квадратного корня из числа. Если из числа невозможно найти целочисленный квадратный корень — возвращаем -1.
```java
// сигнатура метода
public static int sqrt(int target) {
 // TODO
}
```

#### Простое число
Этот метод определяет простоту входящего числа. Он отвечает на вопрос: число простое?
```java
// сигнатура метода
public static boolean isPrime(int target) {
 // TODO
}
```

#### Поиск простого числа
Данный метод должен находить ближайшее простое число в большую сторону от входящего числа.  
Если входящее число уже является простым — его и возвращаем. Не забываем проверять легальность аргумента.
```java
// сигнатура метода
public static int findNextPrime(int target) {
  // TODO
}
```

#### Сортировка чисел
Этот метод принимает на вход массив целых чисел. Его задача отсортировать числа в порядке возрастания.
```java
// сигнатура метода
public static void sort(int[] target) {
  // TODO
}
```

### Класс Point
Создать класс Point, который описывает точку на плоскости.
```java
// сигнатура  класса
public class Point implements Comparable<Point> {
  // ... 
}
```

#### Point
Создать конструктор, который принимает две координаты и сохраняет их в своих полях.
```java
// сигнатура конструктора
public Point(final int coordinateX, final int coordinateY) {
  // TO DO
}
```

#### getX
Написать метод **getX()**, который возвращает координату X, которая была передана конструктору.
```java
// сигнатура метода
public int getX() {
   // TO DO
}
```

#### getY
Написать метод **getY()**, который возвращает координату Y, которая была передана конструктору.
```java
// сигнатура метода
public int getY() {
   // TO DO
}
```

#### sum
Написать метод **sum(final Point that)**, который возвращает новую точку. Координаты новой точки равны: координата X равна сумме координаты X текущей точки и координаты X входящей точки, а координата Y — сумме координаты Y текущей точки и координаты Y входящей точки.
```java
// сигнатура метода
public Point sum(final Point that) {
   // TO DO
}
```

#### updateX
Написать метод **updateX(int newX)**, который создает новую координату: Y остается старой, X — обновляем на newX.
```java
// сигнатура метода
public Point updateX(int newX) {
   // TO DO
}
```

#### updateY
Написать метод **updateY(int newY)**, который создает новую координату: X остается старой, Y — обновляем на newY.
```java
// сигнатура метода
public Point updateY(int newY) {
   // TO DO
}
```

#### distanceTo
Написать метод **distanceTo(Point that)**, который считает и возвращает расстояние от текущей точки A(X1, Y1) до входящей точки B(X2, Y2) по формуле:   (A.X1 - B.X2)<sup>2</sup> + (A.Y1 - B.Y2)<sup>2</sup> (да — эта формула упрощена намеренно).
```java
// сигнатура метода
public int distanceTo(Point that) {
   // TO DO
}
```

#### equals
Написать метод **equals(Object o)**, который сравнивает координаты текущей точки this с координатами входящего объекта o. Метод должен соответствовать лучшим практикам ```equals()```, которые описаны [здесь](https://medium.com/better-programming/equality-and-comparison-in-java-pitfalls-and-best-practices-96b713e7009). Тема на [Stack Overflow](https://ru.stackoverflow.com/questions/460883/idea-%D1%81%D0%B3%D0%B5%D0%BD%D0%B5%D1%80%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BB%D0%B0-equals-%D0%BF%D0%BE%D0%BC%D0%BE%D0%B3%D0%B8%D1%82%D0%B5-%D1%80%D0%B0%D0%B7%D0%BE%D0%B1%D1%80%D0%B0%D1%82%D1%8C%D1%81%D1%8F).
```java
// сигнатура метода
@Override
public boolean equals(Object o) {
   // TO DO
}
```

#### hashCode
Написать метод **hashCode()**, который возвращает сумму координат X и Y текущей точки.
```java
// сигнатура метода
@Override
public int hashCode() {
   // TO DO
}
```

#### toString
Написать метод **toString()**, который должен создавать строку: “Point{X: %d, Y: %d}”.
```java
// сигнатура метода
@Override
public String toString() {
   // TO DO
} 
```

#### compareTo
Написать метод **compareTo(Point that)**, который вернет отрицательное число, если сумма координат X и Y входящей точки that больше суммы координат X и Y текущей точки this. В противном случае метод должен вернуть положительное целое число. Метод должен вернуть 0, если суммы равны.
```java
// сигнатура метода
@Override 
public int compareTo(Point that) {
   // TO DO
}
```
